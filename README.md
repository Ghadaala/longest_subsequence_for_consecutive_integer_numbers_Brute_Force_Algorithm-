# longest_subsequence_for_consecutive_integer_numbers_Brute_Force_Algorithm 
 This brute force algorithm to solve the problem to find the length of #the longest consecutive integers subsequence
In this solving problem, we develop an algorithm to find the length of the longest subsequence of consecutive integer numbers; there are two methods, first is a brute-force approach which iterates over each element in the array, and starts to check all possible results if there is a required subsequence until all numbers have checked in the array If a consecutive number exists, then update the count/variable of the longest concoctive subsequence, continue looping until all numbers have been checked.
     On the other hand, Hashing is an excellent choice and efficient to deliver a map or a set with less complexity. It iterates over all elements of the array only one time. The algorithm creates a Hash table/set and checks if its current number is available in the hash table/set. If itâ€™s not, it starts for a new trail of consecutive subsequences. After each phase, the algorithm keeps updating the length of the longest subsequence-generated array. The complexity of a brute force algorithm has O(n^2), and this algorithm consumes more time. For Hashing algorithm, a time complexity has O(n), a linear search that is much less time-consuming than a brute force algorithm. Finally, we need to mention that the space complexity of a brute force is O(1) because it does not take any auxiliary memory space. In the Hashing method, space complexity is O(n) because we create a Hash tablet and takes maintained it.
      In conclusion, the optimization of Hashing algorithm is a more efficient algorithm than the brute force algorithm, which means making hashing a good choice for the decision to implement Python code, for this problem defiantly.

